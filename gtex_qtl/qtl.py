"""
QTL calling
"""

import logging
import numpy as np

from . import vcf

logger = logging.getLogger(__name__)

def split_genes(expression_df, n_bins):
    """
    Allocates genes in bins such that bins are within the same chromosomes

    Args:
        expression_df: Pandas data frame of genes with the chromosome id as the
            first column (this is in line with the BED file format, which has
            columns standardized by position but not by name) n_bins: number of
            bins to make. If less than the number of chromosomes
            in `expression_df`, it will be increased to that number.

    Returns: list of pairs of indexes, corresponding to the first and last gene
        of each bin, inclusive.
    """

    chrom_col = expression_df.columns[0]

    grouped_edf = expression_df.reset_index().groupby(chrom_col)
    genes_per_chrom = grouped_edf.size()

    n_bins = max(n_bins, len(genes_per_chrom))

    # Allocate one bin to each chrom
    bins = genes_per_chrom // genes_per_chrom

    # Allocate the rest priorizing minimizing max bin size
    for _ in range(bins.sum(), n_bins):
        largest_bin = (genes_per_chrom / bins).argmax()
        bins.iloc[largest_bin] += 1

    assert bins.sum() == n_bins

    # Finally, generate the required number of intervals per chrom
    chrom_bounds = (
            grouped_edf['index']
            .agg([np.min])
            .assign(bins=bins, genes=genes_per_chrom)
            )


    # Mind the rounding: int(x + .5) will consistently give the integer x is
    # close to and int(x - .5) the integer below when x is close to an integer
    # boundary
    pairs = [(
            int(start + i * genes / c_bins + .5),
            int(start + (i+1) * genes / c_bins - .5)
            )
        for _, (start, c_bins, genes) in chrom_bounds.iterrows()
        for i in range(c_bins)
        ]

    assert sum(last - first + 1 for first, last in pairs) == len(expression_df)
    assert all(expression_df[chrom_col].iloc[first] == expression_df[chrom_col].iloc[last]
            for first, last in pairs)

    return pairs

def call_qtls(expression_df, gene_window_indexes, vcf_path, vcf_index=None, window_size=10**6):
    """
    Draft QTL calling.

    Args:
        expression_df: gene expression data frame. First column must be the
            chromosome id, second the start gene of the gene feature (`start`
            thereafter) ; all other columns are phenotypes.
        gene_window_indexes: tuple (first, last) of numeric indexes, inclusive,
            delimiting the rows of `expression_df` to process. Both rows, and
            all the ones in between must be located in the same chromosome and
            sorted by the `start` field.
        window_size: number of bases upstream and downstream of the `start`
        vcf_path: path to the BGZIP-compressed vcf containing the genotypes in
            "GT" format.
        vcf_index: simple index generated by :func:`gtex_qtl.vcf.make_simple_index`.
            If not given, will be generated on the fly.
    """
    chrom_col, start_col = expression_df.columns[:2]
    gene_meta = expression_df[[chrom_col, start_col]]
    (_, first_meta), (_, last_meta) = (
        gene_meta
        .iloc[list(gene_window_indexes)]
        .iterrows()
        )

    chrom, chrom_last = first_meta[chrom_col], last_meta[chrom_col]
    if chrom != chrom_last:
        raise ValueError('First and last gene must be in the same chromosome '
            f'(got "{chrom}" and "{chrom_last}").')

    genotype_window = (
            int(first_meta[start_col]) - window_size,
            int(last_meta[start_col]) + window_size
            )

    if vcf_index is None:
        logger.info('Indexing VCF')
        vcf_index = vcf.make_simple_index(vcf_path)

    logger.info('Reading genotypes from VCF')
    genotype_meta, genotype_missing, genotype_values = (
            vcf.parse_region_indexed(
                vcf_path, vcf_index,
                chrom, *genotype_window)
            )
    logger.info("Loaded %s sites from %s samples", genotype_values.shape[0],
            genotype_values.shape[1])
    logger.info("%.3f%% missing genotypes",
            100 * np.sum(genotype_missing) / genotype_missing.size)
